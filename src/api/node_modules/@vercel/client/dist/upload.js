"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const https_1 = require("https");
const async_retry_1 = __importDefault(require("async-retry"));
const async_sema_1 = require("async-sema");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
const deploy_1 = require("./deploy");
const isClientNetworkError = (err) => {
    if (err.message) {
        // These are common network errors that may happen occasionally and we should retry if we encounter these
        return (err.message.includes('ETIMEDOUT') ||
            err.message.includes('ECONNREFUSED') ||
            err.message.includes('ENOTFOUND') ||
            err.message.includes('ECONNRESET') ||
            err.message.includes('EAI_FAIL') ||
            err.message.includes('socket hang up') ||
            err.message.includes('network socket disconnected'));
    }
    return false;
};
async function* upload(files, nowConfig, clientOptions, deploymentOptions) {
    const { token, teamId, apiUrl, userAgent } = clientOptions;
    const debug = utils_1.createDebug(clientOptions.debug);
    if (!files && !token && !teamId) {
        debug(`Neither 'files', 'token' nor 'teamId are present. Exiting`);
        return;
    }
    let missingFiles = [];
    debug('Determining necessary files for upload...');
    for await (const event of deploy_1.deploy(files, nowConfig, clientOptions, deploymentOptions)) {
        if (event.type === 'error') {
            if (event.payload.code === 'missing_files') {
                missingFiles = event.payload.missing;
                debug(`${missingFiles.length} files are required to upload`);
            }
            else {
                return yield event;
            }
        }
        else {
            // If the deployment has succeeded here, don't continue
            if (event.type === 'alias-assigned') {
                debug('Deployment succeeded on file check');
                return yield event;
            }
            yield event;
        }
    }
    const shas = missingFiles;
    yield { type: 'file-count', payload: { total: files, missing: shas } };
    const uploadList = {};
    debug('Building an upload list...');
    const semaphore = new async_sema_1.Sema(700, { capacity: 700 });
    shas.map((sha) => {
        uploadList[sha] = async_retry_1.default(async (bail) => {
            const file = files.get(sha);
            if (!file) {
                debug(`File ${sha} is undefined. Bailing`);
                return bail(new Error(`File ${sha} is undefined`));
            }
            await semaphore.acquire();
            const fPath = file.names[0];
            const stream = fs_1.createReadStream(fPath);
            const { data } = file;
            let err;
            let result;
            try {
                const res = await utils_1.fetch(utils_1.API_FILES, token, {
                    agent: new https_1.Agent({ keepAlive: true }),
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/octet-stream',
                        'Content-Length': data.length,
                        'x-now-digest': sha,
                        'x-now-size': data.length,
                    },
                    body: stream,
                    teamId,
                    apiUrl,
                    userAgent,
                }, clientOptions.debug, true);
                if (res.status === 200) {
                    debug(`File ${sha} (${file.names[0]}${file.names.length > 1 ? ` +${file.names.length}` : ''}) uploaded`);
                    result = {
                        type: 'file-uploaded',
                        payload: { sha, file },
                    };
                }
                else if (res.status > 200 && res.status < 500) {
                    // If something is wrong with our request, we don't retry
                    debug(`An internal error occurred in upload request. Not retrying...`);
                    const { error } = await res.json();
                    err = new errors_1.DeploymentError(error);
                }
                else {
                    // If something is wrong with the server, we retry
                    debug(`A server error occurred in upload request. Retrying...`);
                    const { error } = await res.json();
                    throw new errors_1.DeploymentError(error);
                }
            }
            catch (e) {
                debug(`An unexpected error occurred in upload promise:\n${e}`);
                err = new Error(e);
            }
            finally {
                stream.close();
                stream.destroy();
            }
            semaphore.release();
            if (err) {
                if (isClientNetworkError(err)) {
                    debug('Network error, retrying: ' + err.message);
                    // If it's a network error, we retry
                    throw err;
                }
                else {
                    debug('Other error, bailing: ' + err.message);
                    // Otherwise we bail
                    return bail(err);
                }
            }
            return result;
        }, {
            retries: 5,
            factor: 6,
            minTimeout: 10,
        });
    });
    debug('Starting upload');
    while (Object.keys(uploadList).length > 0) {
        try {
            const event = await Promise.race(Object.keys(uploadList).map((key) => uploadList[key]));
            delete uploadList[event.payload.sha];
            yield event;
        }
        catch (e) {
            return yield { type: 'error', payload: e };
        }
    }
    debug('All files uploaded');
    yield { type: 'all-files-uploaded', payload: files };
    try {
        debug('Starting deployment creation');
        for await (const event of deploy_1.deploy(files, nowConfig, clientOptions, deploymentOptions)) {
            if (event.type === 'alias-assigned') {
                debug('Deployment is ready');
                return yield event;
            }
            yield event;
        }
    }
    catch (e) {
        debug('An unexpected error occurred when starting deployment creation');
        yield { type: 'error', payload: e };
    }
}
exports.upload = upload;
