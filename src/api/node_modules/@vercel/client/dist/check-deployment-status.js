"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sleep_promise_1 = __importDefault(require("sleep-promise"));
const ms_1 = __importDefault(require("ms"));
const utils_1 = require("./utils");
const ready_state_1 = require("./utils/ready-state");
const utils_2 = require("./utils");
/* eslint-disable */
async function* checkDeploymentStatus(deployment, clientOptions) {
    const { version } = deployment;
    const { token, teamId, apiUrl, userAgent } = clientOptions;
    const debug = utils_2.createDebug(clientOptions.debug);
    let deploymentState = deployment;
    const apiDeployments = utils_1.getApiDeploymentsUrl({
        version,
        builds: deployment.builds,
        functions: deployment.functions,
    });
    debug(`Using ${version ? `${version}.0` : '2.0'} API for status checks`);
    // If the deployment is ready, we don't want any of this to run
    if (ready_state_1.isDone(deploymentState) && ready_state_1.isAliasAssigned(deploymentState)) {
        debug(`Deployment is already READY and aliases are assigned. Not running status checks`);
        return;
    }
    // Build polling
    debug('Waiting for builds and the deployment to complete...');
    const finishedEvents = new Set();
    while (true) {
        // Deployment polling
        const deploymentData = await utils_1.fetch(`${apiDeployments}/${deployment.id || deployment.deploymentId}${teamId ? `?teamId=${teamId}` : ''}`, token, { apiUrl, userAgent });
        const deploymentUpdate = await deploymentData.json();
        if (deploymentUpdate.error) {
            debug('Deployment status check has errorred');
            return yield { type: 'error', payload: deploymentUpdate.error };
        }
        if (deploymentUpdate.readyState === 'BUILDING' &&
            !finishedEvents.has('building')) {
            debug('Deployment state changed to BUILDING');
            finishedEvents.add('building');
            yield { type: 'building', payload: deploymentUpdate };
        }
        if (deploymentUpdate.readyState === 'CANCELED' &&
            !finishedEvents.has('canceled')) {
            debug('Deployment state changed to CANCELED');
            finishedEvents.add('canceled');
            yield { type: 'canceled', payload: deploymentUpdate };
        }
        if (ready_state_1.isReady(deploymentUpdate) && !finishedEvents.has('ready')) {
            debug('Deployment state changed to READY');
            finishedEvents.add('ready');
            yield { type: 'ready', payload: deploymentUpdate };
        }
        if (ready_state_1.isAliasAssigned(deploymentUpdate)) {
            debug('Deployment alias assigned');
            return yield { type: 'alias-assigned', payload: deploymentUpdate };
        }
        if (ready_state_1.isAliasError(deploymentUpdate)) {
            return yield { type: 'error', payload: deploymentUpdate.aliasError };
        }
        if (deploymentUpdate.readyState === 'ERROR' &&
            deploymentUpdate.errorCode === 'BUILD_FAILED') {
            return yield { type: 'error', payload: deploymentUpdate };
        }
        if (ready_state_1.isFailed(deploymentUpdate)) {
            return yield {
                type: 'error',
                payload: deploymentUpdate.error || deploymentUpdate,
            };
        }
        await sleep_promise_1.default(ms_1.default('1.5s'));
    }
}
exports.checkDeploymentStatus = checkDeploymentStatus;
