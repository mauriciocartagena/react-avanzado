"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_extra_1 = require("fs-extra");
const recursive_readdir_1 = __importDefault(require("recursive-readdir"));
const path_1 = require("path");
const hashes_1 = __importStar(require("./utils/hashes"));
const upload_1 = require("./upload");
const utils_1 = require("./utils");
const errors_1 = require("./errors");
function buildCreateDeployment(version) {
    return async function* createDeployment(clientOptions, deploymentOptions = {}, nowConfig = {}) {
        const { path } = clientOptions;
        const debug = utils_1.createDebug(clientOptions.debug);
        const cwd = process.cwd();
        debug('Creating deployment...');
        if (typeof path !== 'string' && !Array.isArray(path)) {
            debug(`Error: 'path' is expected to be a string or an array. Received ${typeof path}`);
            throw new errors_1.DeploymentError({
                code: 'missing_path',
                message: 'Path not provided',
            });
        }
        if (typeof clientOptions.token !== 'string') {
            debug(`Error: 'token' is expected to be a string. Received ${typeof clientOptions.token}`);
            throw new errors_1.DeploymentError({
                code: 'token_not_provided',
                message: 'Options object must include a `token`',
            });
        }
        clientOptions.isDirectory =
            !Array.isArray(path) && fs_extra_1.lstatSync(path).isDirectory();
        let rootFiles;
        if (Array.isArray(path)) {
            for (const filePath of path) {
                if (!path_1.isAbsolute(filePath)) {
                    throw new errors_1.DeploymentError({
                        code: 'invalid_path',
                        message: `Provided path ${filePath} is not absolute`,
                    });
                }
            }
        }
        else if (!path_1.isAbsolute(path)) {
            throw new errors_1.DeploymentError({
                code: 'invalid_path',
                message: `Provided path ${path} is not absolute`,
            });
        }
        if (clientOptions.isDirectory && !Array.isArray(path)) {
            debug(`Provided 'path' is a directory. Reading subpaths... `);
            rootFiles = await fs_extra_1.readdir(path);
            debug(`Read ${rootFiles.length} subpaths`);
        }
        else if (Array.isArray(path)) {
            debug(`Provided 'path' is an array of file paths`);
            rootFiles = path;
        }
        else {
            debug(`Provided 'path' is a single file`);
            rootFiles = [path];
        }
        // Get .nowignore
        let { ig, ignores } = await utils_1.getVercelIgnore(path);
        debug(`Found ${ig.ignores.length} rules in .nowignore`);
        let fileList;
        debug('Building file tree...');
        if (clientOptions.isDirectory && !Array.isArray(path)) {
            // Directory path
            const dirContents = await recursive_readdir_1.default(path, ignores);
            const relativeFileList = dirContents.map(filePath => path_1.relative(process.cwd(), filePath));
            fileList = ig
                .filter(relativeFileList)
                .map((relativePath) => path_1.join(process.cwd(), relativePath));
            debug(`Read ${fileList.length} files in the specified directory`);
        }
        else if (Array.isArray(path)) {
            // Array of file paths
            fileList = path;
            debug(`Assigned ${fileList.length} files provided explicitly`);
        }
        else {
            // Single file
            fileList = [path];
            debug(`Deploying the provided path as single file`);
        }
        let configPath;
        if (!nowConfig) {
            // If the user did not provide a config file, use the one in the root directory.
            configPath = fileList
                .map(f => path_1.relative(cwd, f))
                .find(f => f === 'vercel.json' || f === 'now.json');
            nowConfig = await utils_1.parseNowJSON(configPath);
        }
        if (version === 1 &&
            nowConfig &&
            Array.isArray(nowConfig.files) &&
            nowConfig.files.length > 0) {
            // See the docs: https://vercel.com/docs/v1/features/configuration/#files-(array)
            debug(`Filtering file list based on \`files\` key in "${configPath}"`);
            const allowedFiles = new Set(['Dockerfile']);
            const allowedDirs = new Set();
            nowConfig.files.forEach(relPath => {
                if (fs_extra_1.lstatSync(relPath).isDirectory()) {
                    allowedDirs.add(relPath);
                }
                else {
                    allowedFiles.add(relPath);
                }
            });
            fileList = fileList.filter(absPath => {
                const relPath = path_1.relative(cwd, absPath);
                if (allowedFiles.has(relPath)) {
                    return true;
                }
                for (let dir of allowedDirs) {
                    if (relPath.startsWith(dir + '/')) {
                        return true;
                    }
                }
                return false;
            });
            debug(`Found ${fileList.length} files: ${JSON.stringify(fileList)}`);
        }
        // This is a useful warning because it prevents people
        // from getting confused about a deployment that renders 404.
        if (fileList.length === 0 ||
            fileList.every(f => (f ? path_1.basename(f).startsWith('.') : true))) {
            debug(`Deployment path has no files (or only dotfiles). Yielding a warning event`);
            yield {
                type: 'warning',
                payload: 'There are no files (or only files starting with a dot) inside your deployment.',
            };
        }
        const files = await hashes_1.default(fileList);
        debug(`Yielding a 'hashes-calculated' event with ${files.size} hashes`);
        yield { type: 'hashes-calculated', payload: hashes_1.mapToObject(files) };
        if (clientOptions.apiUrl) {
            debug(`Using provided API URL: ${clientOptions.apiUrl}`);
        }
        if (clientOptions.userAgent) {
            debug(`Using provided user agent: ${clientOptions.userAgent}`);
        }
        debug(`Setting platform version to ${version}`);
        deploymentOptions.version = version;
        debug(`Creating the deployment and starting upload...`);
        for await (const event of upload_1.upload(files, nowConfig, clientOptions, deploymentOptions)) {
            debug(`Yielding a '${event.type}' event`);
            yield event;
        }
    };
}
exports.default = buildCreateDeployment;
