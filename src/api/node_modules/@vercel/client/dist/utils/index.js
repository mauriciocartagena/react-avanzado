"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const fetch_1 = require("./fetch");
const path_1 = require("path");
const querystring_1 = __importDefault(require("querystring"));
const ignore_1 = __importDefault(require("ignore"));
const pkg_1 = require("../pkg");
const async_sema_1 = require("async-sema");
const fs_extra_1 = require("fs-extra");
const semaphore = new async_sema_1.Sema(10);
exports.API_FILES = '/v2/now/files';
exports.API_DELETE_DEPLOYMENTS_LEGACY = '/v2/now/deployments';
const EVENTS_ARRAY = [
    // File events
    'hashes-calculated',
    'file-count',
    'file-uploaded',
    'all-files-uploaded',
    // Deployment events
    'created',
    'building',
    'ready',
    'alias-assigned',
    'warning',
    'error',
    'notice',
    'tip',
    'canceled',
];
exports.EVENTS = new Set(EVENTS_ARRAY);
function getApiDeploymentsUrl(metadata) {
    if (metadata && metadata.version !== 2) {
        return '/v3/now/deployments';
    }
    if (metadata && metadata.builds && !metadata.functions) {
        return '/v10/now/deployments';
    }
    return '/v12/now/deployments';
}
exports.getApiDeploymentsUrl = getApiDeploymentsUrl;
async function parseNowJSON(filePath) {
    if (!filePath) {
        return {};
    }
    try {
        const jsonString = await fs_extra_1.readFile(filePath, 'utf8');
        return JSON.parse(jsonString);
    }
    catch (e) {
        // eslint-disable-next-line no-console
        console.error(e);
        return {};
    }
}
exports.parseNowJSON = parseNowJSON;
const maybeRead = async function (path, default_) {
    try {
        return await fs_extra_1.readFile(path, 'utf8');
    }
    catch (err) {
        return default_;
    }
};
async function getVercelIgnore(cwd) {
    const ignores = [
        '.hg/',
        '.git/',
        '.gitmodules',
        '.svn/',
        '.cache',
        '.next/',
        '.now/',
        '.vercel/',
        '.npmignore',
        '.dockerignore',
        '.gitignore',
        '.*.swp',
        '.DS_Store',
        '.wafpicke-*',
        '.lock-wscript',
        '.env.local',
        '.env.*.local',
        '.venv',
        'npm-debug.log',
        'config.gypi',
        'node_modules/',
        '__pycache__/',
        'venv/',
        'CVS',
    ];
    const cwds = Array.isArray(cwd) ? cwd : [cwd];
    const files = await Promise.all(cwds.map(async (cwd) => {
        const [vercelignore, nowignore] = await Promise.all([
            maybeRead(path_1.join(cwd, '.vercelignore'), ''),
            maybeRead(path_1.join(cwd, '.nowignore'), ''),
        ]);
        if (vercelignore && nowignore) {
            throw new Error('Cannot use both a `.vercelignore` and `.nowignore` file. Please delete the `.nowignore` file.');
        }
        return vercelignore || nowignore;
    }));
    const ignoreFile = files.join('\n');
    const ig = ignore_1.default().add(`${ignores.join('\n')}\n${clearRelative(ignoreFile)}`);
    return { ig, ignores };
}
exports.getVercelIgnore = getVercelIgnore;
/**
 * Remove leading `./` from the beginning of ignores
 * because ignore doesn't like them :|
 */
function clearRelative(str) {
    return str.replace(/(\n|^)\.\//g, '$1');
}
exports.fetch = async (url, token, opts = {}, debugEnabled, useNodeFetch) => {
    semaphore.acquire();
    const debug = createDebug(debugEnabled);
    let time;
    url = `${opts.apiUrl || 'https://api.vercel.com'}${url}`;
    delete opts.apiUrl;
    if (opts.teamId) {
        const parsedUrl = url_1.parse(url, true);
        const query = parsedUrl.query;
        query.teamId = opts.teamId;
        url = `${parsedUrl.href}?${querystring_1.default.encode(query)}`;
        delete opts.teamId;
    }
    const userAgent = opts.userAgent || `now-client-v${pkg_1.pkgVersion}`;
    delete opts.userAgent;
    opts.headers = {
        ...opts.headers,
        authorization: `Bearer ${token}`,
        accept: 'application/json',
        'user-agent': userAgent,
    };
    debug(`${opts.method || 'GET'} ${url}`);
    time = Date.now();
    const res = useNodeFetch
        ? await fetch_1.nodeFetch(url, opts)
        : await fetch_1.zeitFetch(url, opts);
    debug(`DONE in ${Date.now() - time}ms: ${opts.method || 'GET'} ${url}`);
    semaphore.release();
    return res;
};
const isWin = process.platform.includes('win');
exports.prepareFiles = (files, clientOptions) => {
    const preparedFiles = [...files.keys()].reduce((acc, sha) => {
        const next = [...acc];
        const file = files.get(sha);
        for (const name of file.names) {
            let fileName;
            if (clientOptions.isDirectory) {
                // Directory
                fileName =
                    typeof clientOptions.path === 'string'
                        ? path_1.relative(clientOptions.path, name)
                        : name;
            }
            else {
                // Array of files or single file
                const segments = name.split(path_1.sep);
                fileName = segments[segments.length - 1];
            }
            next.push({
                file: isWin ? fileName.replace(/\\/g, '/') : fileName,
                size: file.data.byteLength || file.data.length,
                mode: file.mode,
                sha,
            });
        }
        return next;
    }, []);
    return preparedFiles;
};
function createDebug(debug) {
    if (debug) {
        return (...logs) => {
            process.stderr.write([`[now-client-debug] ${new Date().toISOString()}`, ...logs].join(' ') +
                '\n');
        };
    }
    return () => { };
}
exports.createDebug = createDebug;
